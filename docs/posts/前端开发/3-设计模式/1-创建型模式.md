---
title: 创建型模式
date: 2024-08-01
---

---

## 单例模式（Singleton Pattern）

确保一个类只有一个实例，并提供全局访问点。
用于创建全局唯一的对象，例如全局状态管理器、全局配置对象等。

```javascript
// 使用class类创建实例并且使用Symbol来禁止重复创建
const Singleton = (function () {
    const INSTANCE = Symbol('instance');

    class Singleton {
        constructor() {
            // 判断是否创建过实例
            if (Singleton[INSTANCE]) {
                return Singleton[INSTANCE];
            }
            this.data = "I am the instance";
            // 保存实例
            Singleton[INSTANCE] = this;
        }
    }

    return Singleton;
})();

const instance1 = new Singleton();
const instance2 = new Singleton();

console.log(instance1 === instance2); // true

```

## 工厂方法模式（Factory Pattern）

定义一个创建对象的接口，但由子类决定实例化哪个类。
用于创建不同类型的对象，例如创建不同类型的组件、创建不同类型的数据请求等。

```javascript
// 动物接口（可以是抽象类或接口，这里使用类表示）
class Animal {
    speak() {
        throw new Error("This method should be overridden!");
    }
}

// 狗类，继承自Animal
class Dog extends Animal {
    speak() {
        console.log("Woof! Woof!");
    }
}

// 猫类，继承自Animal
class Cat extends Animal {
    speak() {
        console.log("Meow! Meow!");
    }
}

// 动物工厂类，包含工厂方法
class AnimalFactory {
    // 工厂方法，根据type参数创建不同的动物实例
    createAnimal(type) {
        switch (type) {
            case 'dog':
                return new Dog();
            case 'cat':
                return new Cat();
            default:
                throw new Error("Unknown animal type");
        }
    }
}

// 使用工厂方法模式创建动物实例
const factory = new AnimalFactory();

const dog = factory.createAnimal('dog');
dog.speak(); // 输出: Woof! Woof!

const cat = factory.createAnimal('cat');
cat.speak(); // 输出: Meow! Meow!

```

## 抽象工厂模式（Abstract Factory Pattern）

提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
用于创建一系列相关或相互依赖的对象，例如创建一组相互关联的UI组件。

```javascript
// 动物接口（可以是抽象类或接口，这里使用类表示）
class Animal {
    speak() {
        throw new Error("This method should be overridden!");
    }
}

// 食物接口（可以是抽象类或接口，这里使用类表示）
class Food {
    getType() {
        throw new Error("This method should be overridden!");
    }
}

// 狗类，继承自Animal
class Dog extends Animal {
    speak() {
        console.log("Woof! Woof!");
    }
}

// 猫类，继承自Animal
class Cat extends Animal {
    speak() {
        console.log("Meow! Meow!");
    }
}

// 狗粮类，继承自Food
class DogFood extends Food {
    getType() {
        return "Dog Food";
    }
}

// 猫粮类，继承自Food
class CatFood extends Food {
    getType() {
        return "Cat Food";
    }
}

// 抽象工厂接口（可以是抽象类或接口，这里使用类表示）
class AbstractFactory {
    createAnimal() {
        throw new Error("This method should be overridden!");
    }

    createFood() {
        throw new Error("This method should be overridden!");
    }
}

// 狗工厂类，继承自AbstractFactory
class DogFactory extends AbstractFactory {
    createAnimal() {
        return new Dog();
    }

    createFood() {
        return new DogFood();
    }
}

// 猫工厂类，继承自AbstractFactory
class CatFactory extends AbstractFactory {
    createAnimal() {
        return new Cat();
    }

    createFood() {
        return new CatFood();
    }
}

// 工厂生产器类，用于获取具体的工厂
class FactoryProducer {
    static getFactory(type) {
        switch (type) {
            case 'dog':
                return new DogFactory();
            case 'cat':
                return new CatFactory();
            default:
                throw new Error("Unknown factory type");
        }
    }
}

// 使用抽象工厂模式创建动物和食物实例
const dogFactory = FactoryProducer.getFactory('dog');
const dog = dogFactory.createAnimal();
const dogFood = dogFactory.createFood();
dog.speak(); // 输出: Woof! Woof!
console.log(dogFood.getType()); // 输出: Dog Food

const catFactory = FactoryProducer.getFactory('cat');
const cat = catFactory.createAnimal();
const catFood = catFactory.createFood();
cat.speak(); // 输出: Meow! Meow!
console.log(catFood.getType()); // 输出: Cat Food

```

## 建造者模式（Builder Pattern）

将一个复杂对象的构建过程与其表示分离，使得同样的构建过程可以创建不同的表示。
用于构建复杂对象，例如构建复杂的表单、构建复杂的图表等。

```javascript
// 电脑类
class Computer {
    constructor() {
        this.cpu = null;
        this.ram = null;
        this.storage = null;
        this.gpu = null;
    }

    // 显示电脑的配置
    showConfig() {
        console.log(`CPU: ${this.cpu}`);
        console.log(`RAM: ${this.ram}`);
        console.log(`Storage: ${this.storage}`);
        console.log(`GPU: ${this.gpu}`);
    }
}

// 电脑建造者类
class ComputerBuilder {
    constructor() {
        this.computer = new Computer();
    }

    setCPU(cpu) {
        this.computer.cpu = cpu;
        return this;
    }

    setRAM(ram) {
        this.computer.ram = ram;
        return this;
    }

    setStorage(storage) {
        this.computer.storage = storage;
        return this;
    }

    setGPU(gpu) {
        this.computer.gpu = gpu;
        return this;
    }

    // 返回构建完成的电脑实例
    build() {
        return this.computer;
    }
}

// 指导者类，用于指导构建过程
class Director {
    constructor(builder) {
        this.builder = builder;
    }

    // 构建游戏电脑
    constructGamingComputer() {
        return this.builder
            .setCPU("Intel i9")
            .setRAM("32GB")
            .setStorage("1TB SSD")
            .setGPU("NVIDIA RTX 3080")
            .build();
    }

    // 构建办公电脑
    constructOfficeComputer() {
        return this.builder
            .setCPU("Intel i5")
            .setRAM("16GB")
            .setStorage("512GB SSD")
            .setGPU("Integrated")
            .build();
    }
}

// 使用建造者模式构建电脑实例
const builder = new ComputerBuilder();
const director = new Director(builder);

const gamingComputer = director.constructGamingComputer();
gamingComputer.showConfig();
// 输出:
// CPU: Intel i9
// RAM: 32GB
// Storage: 1TB SSD
// GPU: NVIDIA RTX 3080

const officeComputer = director.constructOfficeComputer();
officeComputer.showConfig();
// 输出:
// CPU: Intel i5
// RAM: 16GB
// Storage: 512GB SSD
// GPU: Integrated

```

## 原型模式（Prototype Pattern）

通过复制现有对象来创建新对象。
用于通过复制现有对象来创建新对象，例如通过克隆已有组件来创建新组件。

```javascript
// 基础形状对象
const Shape = {
    type: "Shape",

    // 克隆方法，用于创建当前对象的副本
    clone() {
        const cloneObj = Object.create(this);
        return cloneObj;
    },

    // 显示形状信息
    showInfo() {
        console.log(`Shape: ${this.type}`);
    }
};

// 圆形对象，继承自Shape
const Circle = Object.create(Shape, {
    type: {value: "Circle"},
    radius: {value: 0, writable: true}
});

// 设置圆形的属性
Circle.setRadius = function (radius) {
    this.radius = radius;
    return this;
};

// 重写显示形状信息方法，包含半径
Circle.showInfo = function () {
    Shape.showInfo.call(this);
    console.log(`Radius: ${this.radius}`);
};

// 矩形对象，继承自Shape
const Rectangle = Object.create(Shape, {
    type: {value: "Rectangle"},
    width: {value: 0, writable: true},
    height: {value: 0, writable: true}
});

// 设置矩形的属性
Rectangle.setDimensions = function (width, height) {
    this.width = width;
    this.height = height;
    return this;
};

// 重写显示形状信息方法，包含宽度和高度
Rectangle.showInfo = function () {
    Shape.showInfo.call(this);
    console.log(`Width: ${this.width}`);
    console.log(`Height: ${this.height}`);
};

// 使用原型模式克隆形状
const circle1 = Object.create(Circle).setRadius(10);
const circle2 = circle1.clone();
circle1.showInfo();
// 输出:
// Shape: Circle
// Radius: 10

circle2.showInfo();
// 输出:
// Shape: Circle
// Radius: 10

const rectangle1 = Object.create(Rectangle).setDimensions(20, 30);
const rectangle2 = rectangle1.clone();
rectangle1.showInfo();
// 输出:
// Shape: Rectangle
// Width: 20
// Height: 30

rectangle2.showInfo();
// 输出:
// Shape: Rectangle
// Width: 20
// Height: 30

```
