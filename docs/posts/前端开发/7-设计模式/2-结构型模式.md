---
title: 结构型模式
date: 2024-08-01
---

---

## 适配器模式（Adapter Pattern）

将一个类的接口转换成客户希望的另外一个接口。
用于将一个类的接口转换成另一个类的接口，例如将不同数据源返回的数据格式统一成统一格式。

假设我们有一个电子商务应用程序，它需要支持不同的支付系统，比如 PayPal 和
Stripe。我们可以使用适配器模式来实现这个需求，使得应用程序可以使用统一的接口来处理不同的支付系统。

```javascript
// 第三方支付系统：PayPal
class PayPal {
    constructor(email) {
        this.email = email;
    }

    // PayPal 支付方法
    sendPayment(amount) {
        console.log(`Sending $${amount} to ${this.email} via PayPal.`);
    }
}

// 第三方支付系统：Stripe
class Stripe {
    constructor(accountId) {
        this.accountId = accountId;
    }

    // Stripe 支付方法
    makePayment(amount) {
        console.log(`Making payment of $${amount} to account ${this.accountId} via Stripe.`);
    }
}

// 统一的支付接口
class PaymentProcessor {
    constructor(adapter) {
        this.adapter = adapter;
    }

    // 支付方法
    pay(amount) {
        this.adapter.pay(amount);
    }
}

// PayPal 适配器
class PayPalAdapter {
    constructor(paypal) {
        this.paypal = paypal;
    }

    // 实现统一支付接口的支付方法
    pay(amount) {
        this.paypal.sendPayment(amount);
    }
}

// Stripe 适配器
class StripeAdapter {
    constructor(stripe) {
        this.stripe = stripe;
    }

    // 实现统一支付接口的支付方法
    pay(amount) {
        this.stripe.makePayment(amount);
    }
}

// 使用适配器模式进行支付
const paypal = new PayPal("user@example.com");
const stripe = new Stripe("account_12345");

const paypalAdapter = new PayPalAdapter(paypal);
const stripeAdapter = new StripeAdapter(stripe);

const paypalPaymentProcessor = new PaymentProcessor(paypalAdapter);
const stripePaymentProcessor = new PaymentProcessor(stripeAdapter);

paypalPaymentProcessor.pay(100);
// 输出: Sending $100 to user@example.com via PayPal.

stripePaymentProcessor.pay(200);
// 输出: Making payment of $200 to account account_12345 via Stripe.

```

## 装饰器模式（Decorator Pattern）

动态地给一个对象添加一些额外的职责。
用于动态地给一个对象添加额外的职责，例如给某个组件添加日志记录功能。

假设我们有一个咖啡店的应用程序，需要根据客户的选择为咖啡添加各种配料（比如牛奶、糖、巧克力等）。我们可以使用装饰器模式来实现这个需求。

```javascript

// 基础饮料类
class Beverage {
    cost() {
        return 0;
    }

    description() {
        return "Unknown Beverage";
    }
}

// 具体饮料类：咖啡
class Coffee extends Beverage {
    cost() {
        return 5;
    }

    description() {
        return "Coffee";
    }
}

// 装饰器类：装饰器基类
class BeverageDecorator extends Beverage {
    constructor(beverage) {
        super();
        this.beverage = beverage;
    }

    cost() {
        return this.beverage.cost();
    }

    description() {
        return this.beverage.description();
    }
}

// 具体装饰器类：牛奶
class MilkDecorator extends BeverageDecorator {
    cost() {
        return this.beverage.cost() + 1;
    }

    description() {
        return `${this.beverage.description()}, Milk`;
    }
}

// 具体装饰器类：糖
class SugarDecorator extends BeverageDecorator {
    cost() {
        return this.beverage.cost() + 0.5;
    }

    description() {
        return `${this.beverage.description()}, Sugar`;
    }
}

// 具体装饰器类：巧克力
class ChocolateDecorator extends BeverageDecorator {
    cost() {
        return this.beverage.cost() + 2;
    }

    description() {
        return `${this.beverage.description()}, Chocolate`;
    }
}

// 使用装饰器模式构建饮料
let beverage = new Coffee();
console.log(`${beverage.description()} $${beverage.cost()}`);
// 输出: Coffee $5

beverage = new MilkDecorator(beverage);
console.log(`${beverage.description()} $${beverage.cost()}`);
// 输出: Coffee, Milk $6

beverage = new SugarDecorator(beverage);
console.log(`${beverage.description()} $${beverage.cost()}`);
// 输出: Coffee, Milk, Sugar $6.5

beverage = new ChocolateDecorator(beverage);
console.log(`${beverage.description()} $${beverage.cost()}`);
// 输出: Coffee, Milk, Sugar, Chocolate $8.5

```

## 外观模式（Facade Pattern）

为子系统中的一组接口提供一个统一的接口。
用于为子系统提供一个简化接口，例如封装复杂UI库提供简单易用的API。

假设我们有一个家庭影院系统，它包括多个子系统，例如DVD播放器、投影仪、环绕音响和灯光控制。我们可以使用外观模式来简化这些子系统的操作。

```javascript
// 子系统类：DVD播放器
class DVDPlayer {
    on() {
        console.log("DVD Player is on.");
    }

    play(movie) {
        console.log(`Playing "${movie}" on DVD Player.`);
    }

    off() {
        console.log("DVD Player is off.");
    }
}

// 子系统类：投影仪
class Projector {
    on() {
        console.log("Projector is on.");
    }

    setInput(input) {
        console.log(`Projector input set to ${input}.`);
    }

    off() {
        console.log("Projector is off.");
    }
}

// 子系统类：环绕音响
class SurroundSoundSystem {
    on() {
        console.log("Surround Sound System is on.");
    }

    setVolume(level) {
        console.log(`Surround Sound System volume set to ${level}.`);
    }

    off() {
        console.log("Surround Sound System is off.");
    }
}

// 子系统类：灯光控制
class LightControl {
    dim() {
        console.log("Lights are dimmed.");
    }

    on() {
        console.log("Lights are on.");
    }
}

// 外观类：家庭影院外观
class HomeTheaterFacade {
    constructor(dvdPlayer, projector, soundSystem, lights) {
        this.dvdPlayer = dvdPlayer;
        this.projector = projector;
        this.soundSystem = soundSystem;
        this.lights = lights;
    }

    watchMovie(movie) {
        console.log("Get ready to watch a movie...");
        this.lights.dim();
        this.projector.on();
        this.projector.setInput("DVD Player");
        this.soundSystem.on();
        this.soundSystem.setVolume(10);
        this.dvdPlayer.on();
        this.dvdPlayer.play(movie);
    }

    endMovie() {
        console.log("Shutting movie theater down...");
        this.dvdPlayer.off();
        this.soundSystem.off();
        this.projector.off();
        this.lights.on();
    }
}

// 使用外观模式控制家庭影院系统
const dvdPlayer = new DVDPlayer();
const projector = new Projector();
const soundSystem = new SurroundSoundSystem();
const lights = new LightControl();

const homeTheater = new HomeTheaterFacade(dvdPlayer, projector, soundSystem, lights);

homeTheater.watchMovie("Inception");
// 输出:
// Get ready to watch a movie...
// Lights are dimmed.
// Projector is on.
// Projector input set to DVD Player.
// Surround Sound System is on.
// Surround Sound System volume set to 10.
// DVD Player is on.
// Playing "Inception" on DVD Player.

homeTheater.endMovie();
// 输出:
// Shutting movie theater down...
// DVD Player is off.
// Surround Sound System is off.
// Projector is off.
// Lights are on.


```

## 桥接模式（Bridge Pattern）

将抽象部分与它们的实现部分分离，使它们可以独立地变化。
用于将抽象部分与实现部分分离，例如将UI组件的样式与行为分离。

假设我们有一个图形绘制的应用程序，需要支持不同的图形（比如圆形和矩形）和不同的绘制方式（比如矢量绘制和位图绘制）。我们可以使用桥接模式来实现这个需求。

```javascript
// 实现接口：绘制接口
class DrawingAPI {
    drawCircle(x, y, radius) {
    }

    drawRectangle(x, y, width, height) {
    }
}

// 具体实现类：矢量绘制
class VectorDrawingAPI extends DrawingAPI {
    drawCircle(x, y, radius) {
        console.log(`Drawing a circle at (${x}, ${y}) with radius ${radius} using Vector Drawing API.`);
    }

    drawRectangle(x, y, width, height) {
        console.log(`Drawing a rectangle at (${x}, ${y}) with width ${width} and height ${height} using Vector Drawing API.`);
    }
}

// 具体实现类：位图绘制
class BitmapDrawingAPI extends DrawingAPI {
    drawCircle(x, y, radius) {
        console.log(`Drawing a circle at (${x}, ${y}) with radius ${radius} using Bitmap Drawing API.`);
    }

    drawRectangle(x, y, width, height) {
        console.log(`Drawing a rectangle at (${x}, ${y}) with width ${width} and height ${height} using Bitmap Drawing API.`);
    }
}

// 抽象类：图形
class Shape {
    constructor(drawingAPI) {
        this.drawingAPI = drawingAPI;
    }

    draw() {
    }
}

// 具体抽象类：圆形
class Circle extends Shape {
    constructor(x, y, radius, drawingAPI) {
        super(drawingAPI);
        this.x = x;
        this.y = y;
        this.radius = radius;
    }

    draw() {
        this.drawingAPI.drawCircle(this.x, this.y, this.radius);
    }
}

// 具体抽象类：矩形
class Rectangle extends Shape {
    constructor(x, y, width, height, drawingAPI) {
        super(drawingAPI);
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }

    draw() {
        this.drawingAPI.drawRectangle(this.x, this.y, this.width, this.height);
    }
}

// 使用桥接模式绘制图形
const vectorAPI = new VectorDrawingAPI();
const bitmapAPI = new BitmapDrawingAPI();

const circle1 = new Circle(5, 10, 15, vectorAPI);
const rectangle1 = new Rectangle(20, 30, 40, 50, bitmapAPI);

circle1.draw();
// 输出: Drawing a circle at (5, 10) with radius 15 using Vector Drawing API.

rectangle1.draw();
// 输出: Drawing a rectangle at (20, 30) with width 40 and height 50 using Bitmap Drawing API.


```

## 组合模式（Composite Pattern）

将对象组合成树形结构以表示“部分-整体”的层次结构。

用于将对象组合成树形结构，例如构建复杂的导航菜单。

假设我们有一个公司组织结构图，其中包含员工和部门。部门可以包含其他部门和员工，而员工没有子项。我们可以使用组合模式来表示这个组织结构图。

```javascript
// 组件接口：组织单元
class OrganizationComponent {
    constructor(name) {
        this.name = name;
    }

    add(component) {
    }

    remove(component) {
    }

    display(depth) {
    }
}

// 叶子类：员工
class Employee extends OrganizationComponent {
    display(depth) {
        console.log('-'.repeat(depth) + this.name);
    }
}

// 组合类：部门
class Department extends OrganizationComponent {
    constructor(name) {
        super(name);
        this.children = [];
    }

    add(component) {
        this.children.push(component);
    }

    remove(component) {
        this.children = this.children.filter(child => child !== component);
    }

    display(depth) {
        console.log('-'.repeat(depth) + this.name);
        this.children.forEach(child => child.display(depth + 2));
    }
}

// 使用组合模式构建组织结构
const ceo = new Department("CEO");
const headSales = new Department("Head of Sales");
const headMarketing = new Department("Head of Marketing");

const sales1 = new Employee("Sales 1");
const sales2 = new Employee("Sales 2");

const marketing1 = new Employee("Marketing 1");
const marketing2 = new Employee("Marketing 2");

headSales.add(sales1);
headSales.add(sales2);

headMarketing.add(marketing1);
headMarketing.add(marketing2);

ceo.add(headSales);
ceo.add(headMarketing);

// 显示组织结构
ceo.display(1);
// 输出:
// -CEO
// --Head of Sales
// ----Sales 1
// ----Sales 2
// --Head of Marketing
// ----Marketing 1
// ----Marketing 2


```

## 享元模式（Flyweight Pattern）

运用共享技术有效地支持大量细粒度的对象。

用于共享细粒度的对象，例如共享相同的图标、共享相同的样式等。

```javascript
// 享元接口：字体
class Font {
    constructor(type, size) {
        this.type = type;
        this.size = size;
    }

    render(character) {
        console.log(`Rendering '${character}' with font type '${this.type}' and size ${this.size}.`);
    }
}

// 享元工厂：字体工厂
class FontFactory {
    constructor() {
        this.fonts = {};
    }

    getFont(type, size) {
        const key = `${type}_${size}`;
        if (!this.fonts[key]) {
            this.fonts[key] = new Font(type, size);
            console.log(`Creating new font: ${key}`);
        } else {
            console.log(`Reusing existing font: ${key}`);
        }
        return this.fonts[key];
    }
}

// 外部状态：字符
class Character {
    constructor(character, font) {
        this.character = character;
        this.font = font;
    }

    display() {
        this.font.render(this.character);
    }
}

// 使用享元模式渲染字符
const fontFactory = new FontFactory();

const font1 = fontFactory.getFont("Arial", 12);
const font2 = fontFactory.getFont("Arial", 12); // Should reuse existing font

const char1 = new Character("A", font1);
const char2 = new Character("B", font1);
const char3 = new Character("C", font2);

char1.display();
// 输出: Rendering 'A' with font type 'Arial' and size 12.
char2.display();
// 输出: Rendering 'B' with font type 'Arial' and size 12.
char3.display();
// 输出: Rendering 'C' with font type 'Arial' and size 12.


```

## 代理模式（Proxy Pattern）

用于控制对某个对象的访问。

例如对某个重要操作进行权限控制。

```javascript
// 真实主题类：银行账户
class BankAccount {
    constructor(balance) {
        this.balance = balance;
    }

    getBalance() {
        return this.balance;
    }

    withdraw(amount) {
        if (amount <= this.balance) {
            this.balance -= amount;
            console.log(`Withdrawn ${amount}, new balance is ${this.balance}`);
        } else {
            console.log('Insufficient funds');
        }
    }
}

// 代理类：银行账户代理
class BankAccountProxy {
    constructor(account, user) {
        this.account = account;
        this.user = user;
    }

    getBalance() {
        return this.account.getBalance();
    }

    withdraw(amount) {
        if (this.user.role === 'admin') {
            this.account.withdraw(amount);
        } else {
            console.log('Access denied: Only admins can withdraw money');
        }
    }
}

// 客户端代码
const account = new BankAccount(1000);

const user = {role: 'user'};
const admin = {role: 'admin'};

const userProxy = new BankAccountProxy(account, user);
const adminProxy = new BankAccountProxy(account, admin);

console.log('User trying to get balance:');
console.log(`Balance: ${userProxy.getBalance()}`); // 可以查看余额

console.log('User trying to withdraw money:');
userProxy.withdraw(100); // 访问被拒绝

console.log('Admin trying to withdraw money:');
adminProxy.withdraw(100); // 成功取款

console.log('Admin trying to get balance:');
console.log(`Balance: ${adminProxy.getBalance()}`); // 可以查看余额

```
